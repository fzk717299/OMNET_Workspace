[General]
cmdenv-express-mode = true
cmdenv-autoflush = true
image-path = ../../images
network = simu5g.simulations.Iov_scenario1.IovScenario

# Simulation parameters
debug-on-errors = false
print-undisposed = false
sim-time-limit=70s
**.udp.e2eDelay.vector-recording = true
*.rsu.udp.scalar-recording = true
*.car[0].udp.scalar-recording = true

*.playgroundSizeX = 20000m
*.playgroundSizeY = 20000m
*.playgroundSizeZ = 50m

# VeinsManager parameters
*.veinsManager.host = "localhost"
*.veinsManager.moduleType = "simu5g.nodes.cars.Car"
*.veinsManager.moduleName = "car"
*.veinsManager.launchConfig = xmldoc("heterogeneous.launchd.xml")
*.veinsManager.updateInterval = 0.1s
*.veinsManager.autoShutdown = true  # 自动关闭SUMO
*.veinsManager.margin = 25  # 增加边界余量
#*.veinsManager.launchd.sumocfg = "heterogeneous.sumocfg"  # 明确指定SUMO配置文件

# Mobility parameters for dynamic nodes (cars)
*.car[*].mobilityType = "VeinsInetMobility"


# LTE specific parameters
**.numBands = 25
**.ueTxPower = 26
**.eNodeBTxPower = 46
**.sinrThreshold = 0dB

# Dynamic cell association for mobile nodes
*.car[*].cellularNic.phy.dynamicCellAssociation = true
**.car[*].masterId = 1
**.car[*].macCellId = 1

# --- RSU Wireless Configuration ---
# RSU UE configuration
*.rsu.cellularNic.phy.dynamicCellAssociation = true
*.rsu.masterId = 1
*.rsu.macCellId = 1
*.rsu.mobilityType = "StationaryMobility"
*.rsu.mobility.initialX = 561m
*.rsu.mobility.initialY = 42m
*.rsu.mobility.initialZ = 0m
*.rsu.cellularNic.phy.ueTxPower = 30mW

# Register RSU as an active UE with the Binder
*.binder.ueList = "rsu car[*]"
# --- End of RSU Configuration ---

# eNodeB configuration
**.eNodeB1.macCellId = 1
**.eNodeB1.macNodeId = 1
**.eNodeB2.macCellId = 2
**.eNodeB2.macNodeId = 2

# Enable handover
*.car[*].cellularNic.phy.enableHandover = true
*.eNodeB*.cellularNic.phy.enableHandover = true
*.eNodeB*.cellularNic.phy.handoverLatency = uniform(40ms, 60ms)
*.eNodeB*.cellInfo.broadcastMessageInterval = 1s

# X2 and SCTP configuration
*.eNodeB1.numX2Apps = 2
*.eNodeB2.numX2Apps = 2
*.eNodeB3.numX2Apps = 2

# eNodeB1 connections
*.eNodeB1.x2App[0].client.connectAddress = "eNodeB2%x2ppp0"
*.eNodeB1.x2App[1].client.connectAddress = "eNodeB3%x2ppp0"

# eNodeB2 connections
*.eNodeB2.x2App[0].client.connectAddress = "eNodeB1%x2ppp0"
*.eNodeB2.x2App[1].client.connectAddress = "eNodeB3%x2ppp0"

# eNodeB3 connections
*.eNodeB3.x2App[0].client.connectAddress = "eNodeB1%x2ppp0"
*.eNodeB3.x2App[1].client.connectAddress = "eNodeB2%x2ppp0"

# Common X2 configuration
**.eNodeB*.x2App[*].server.localPort = 5000 + ancestorIndex(1)
**.eNodeB*.x2App[*].client.connectPort = 5000
**.eNodeB*.x2App[*].client.startTime = 0.5s
**.sctp.nagleEnabled = false
**.sctp.enableHeartbeats = false

# --- Config for RSU -> Cloud -> Car Communication ---
[Config RSU-Cloud-Car]
# Application Setup using UdpBasicApp for reliable performance measurement

# RSU sends data to the server
*.rsu.numApps = 1
*.rsu.app[0].typename = "UdpBasicApp"
*.rsu.app[0].destAddresses = "server"
*.rsu.app[0].destPort = 5000
*.rsu.app[0].messageLength = 1000B
*.rsu.app[0].sendInterval = 0.02s
*.rsu.app[0].startTime = 1s

# Server acts as a relay: receives from RSU and sends to car[0]
*.server.numApps = 2
# App 0 receives from RSU (parameters are placeholders but required)
*.server.app[0].typename = "UdpBasicApp"
*.server.app[0].localPort = 5000
*.server.app[0].destAddresses = ""
*.server.app[0].destPort = 5000
*.server.app[0].messageLength = 0B
*.server.app[0].sendInterval = 0s # Never sends
*.server.app[0].startTime = 0s

# App 1 sends to car[0]
*.server.app[1].typename = "UdpBasicApp"
*.server.app[1].destAddresses = "car[0]"
*.server.app[1].destPort = 5001
*.server.app[1].messageLength = 1000B
*.server.app[1].sendInterval = 0.02s
*.server.app[1].startTime = 1.1s # Simulate processing delay

# All cars are configured to receive, but only car[0] will get data
*.car[*].numApps = 1
*.car[*].app[0].typename = "UdpBasicApp"
*.car[*].app[0].localPort = 5001
*.car[*].app[0].destAddresses = "" # Not used, but required
*.car[*].app[0].destPort = 5001      # Not used, but required
*.car[*].app[0].messageLength = 0B   # Not used, but required
*.car[*].app[0].sendInterval = 0s # Never sends
*.car[*].app[0].startTime = 0s


# --- Statistics Recording Setup (Correct Syntax & Location) ---

# 1. End-to-End Delay (Vector)
*.car[0].udp.e2eDelay:vector.recording = true
# 添加对SpeedLimitCarApp的端到端延迟测量
*.car[0].app[0].endToEndDelay:vector.recording = true

# 2. Throughput (Vector)
*.car[0].app[0].rcvdPk:throughput:vector.recording = true

# 3. Packet Loss Calculation (Scalars)
*.rsu.udp.sentPk:count.recording = true
*.car[0].udp.rcvdPk:count.recording = true
# 添加对自定义应用的包计数统计
*.car[0].app[0].speedCommandReceived:count.recording = true

############### Statistics ##################
output-scalar-file = ${resultdir}/${configname}/${repetition}.sca
output-vector-file = ${resultdir}/${configname}/${repetition}.vec

# --- Measurement of Bandwidth Utilization and Load ---

# 1. Bandwidth Utilization on the Core Network Link (Router <-> PGW)
# This records the utilization of the 10G Ethernet link.
# The result is a value between 0 and 1.
**.pgw.pppg[0].channel.utilization:vector.recording = true

# 2. Cell Load (Used PRBs) for each eNodeB
# This records the number of Physical Resource Blocks (PRBs) used in the downlink at each scheduling interval.
# To get the load ratio, this value must be divided by the total available PRBs.
*.eNodeB*.mac.usedPrbsDl:vector.recording = true

# --- Measurement of Physical Layer ---
*.car[*].cellularNic.phy.channelModel.rcvdSinr:vector.recording = true
*.car[*].cellularNic.phy.channelModel.distance:vector.recording = true
*.car[*].cellularNic.phy.channelModel.coverageStatus:vector.recording = true
*.car[*].cellularNic.phy.channelModel.receivedPower:vector.recording = true
*.car[*].cellularNic.phy.channelModel.interferencePower:vector.recording = true

# --- Handover Failure Statistics ---
*.car[*].cellularNic.phy.handoverAttempt:count.recording = true
*.car[*].cellularNic.phy.handoverFailure:count.recording = true
*.car[*].cellularNic.phy.handoverFailureSinrThreshold_dB = -5dB

# --- Signal Strength Change Rate and Connection Interruption Statistics ---
*.car[*].cellularNic.phy.channelModel.rssiChangeRate:vector.recording = true
*.car[*].cellularNic.phy.channelModel.interruptionDuration:vector.recording = true
*.car[*].cellularNic.phy.channelModel.connectionInterruption:count.recording = true
*.car[*].cellularNic.phy.channelModel.connectionRestoration:count.recording = true

# --- Enhanced Network Configuration ---
[Config RSU-Cloud-Car-Enhanced]
extends = RSU-Cloud-Car
# 修复网络引用，使用相对路径而非完整包路径
# network = simu5g.simulations.IovScenario

# Add third eNodeB for better coverage
*.eNodeB3.macCellId = 3
*.eNodeB3.macNodeId = 3
*.eNodeB3.mobility.initialX = 800m
*.eNodeB3.mobility.initialY = 150m
*.eNodeB3.mobility.initialZ = 0m

# eNodeB3 connections are defined in the NED file
# No need to define connections here

# eNodeB3 配置已在上面统一设置

# Additional statistics for connection monitoring
# Using standard OMNeT++ statistics
*.car[*].cellularNic.phy.*.vector-recording = true

# --- SpeedLimit Application Configuration ---
[Config SpeedLimit]
extends = RSU-Cloud-Car

# RSU使用SpeedLimitRsuApp检测车辆速度并发送给服务器
*.rsu.numApps = 1
*.rsu.app[0].typename = "SpeedLimitRsuApp"
*.rsu.app[0].destAddresses = "server"
*.rsu.app[0].destPort = 5000
*.rsu.app[0].localPort = 5001
*.rsu.app[0].messageLength = 500B
*.rsu.app[0].speedLimitDetectorId = "speedLimitDetector_1"
*.rsu.app[0].maxSpeed = 2kmph  # 降低限速阈值，确保能触发限速功能
*.rsu.app[0].checkInterval = 0.1s

# 服务器使用SpeedLimitServerApp处理并转发控制命令
*.server.numApps = 1
*.server.app[0].typename = "SpeedLimitServerApp"
*.server.app[0].localPort = 5000
*.server.app[0].destPort = 5001
*.server.app[0].messageLength = 500B
*.server.app[0].hasMapSpeedLimit = false
*.server.app[0].processingDelay = 0.05s

# 车辆使用SpeedLimitCarApp接收并执行速度控制命令
*.car[*].numApps = 1
*.car[*].app[0].typename = "SpeedLimitCarApp"
*.car[*].app[0].localPort = 5001
*.car[*].app[0].smoothDeceleration = true
*.car[*].app[0].responseTime = 2.0s

# 自定义应用层指标收集配置
# 车辆应用指标
*.car[*].app[0].endToEndDelay:vector.recording = true
*.car[*].app[0].endToEndDelay:histogram.recording = true
*.car[*].app[0].endToEndDelay:mean.recording = true
*.car[*].app[0].speedCommandReceived:count.recording = true
*.car[*].app[0].speedLimitApplied:vector.recording = true

# RSU应用指标
*.rsu.app[0].speedLimitDetected:vector.recording = true
*.rsu.app[0].speedLimitDetected:count.recording = true

# 服务器应用指标
*.server.app[0].speedLimitCommandSent:vector.recording = true
*.server.app[0].speedLimitCommandSent:count.recording = true
*.server.app[0].messagesProcessed:last.recording = true

# --- VoIP Application Configuration ---
[Config RSU-Cloud-Car-VoIP]
extends = RSU-Cloud-Car

# RSU as VoIP sender - 使用UdpBasicApp模拟VoIP行为
*.rsu.numApps = 1
*.rsu.app[0].typename = "UdpBasicApp"  # 模拟VoIP发送器
*.rsu.app[0].destAddresses = "car[0]"
*.rsu.app[0].destPort = 5001
*.rsu.app[0].localPort = 5000
*.rsu.app[0].startTime = 1s
*.rsu.app[0].messageLength = 100B
# 模拟语音的突发性
*.rsu.app[0].sendInterval = 0.02s + exponential(0.01s)  
*.rsu.app[0].stopTime = 69s

# Server as relay monitor
*.server.numApps = 1
*.server.app[0].typename = "UdpSink"
*.server.app[0].localPort = 5000

# Car as VoIP receiver - 使用UdpSink替代VoIPReceiver
*.car[*].numApps = 1
*.car[*].app[0].typename = "UdpSink"  # 通用接收器
*.car[*].app[0].localPort = 5001

# --- Alert Application Configuration ---
[Config RSU-Cloud-Car-Alert]
extends = RSU-Cloud-Car

# RSU as alert sender
*.rsu.numApps = 1
*.rsu.app[0].typename = "UdpBasicApp"  # Simulating AlertSender
*.rsu.app[0].destAddresses = "224.0.0.10"  # Multicast address
*.rsu.app[0].destPort = 5001
*.rsu.app[0].localPort = 5000
*.rsu.app[0].messageLength = 500B  # Smaller emergency messages
*.rsu.app[0].sendInterval = exponential(5s)  # Random alerts
*.rsu.app[0].startTime = 1s

# Server as alert processor
*.server.numApps = 1
*.server.app[0].typename = "UdpSink"
*.server.app[0].localPort = 5002

# Cars as alert receivers
*.car[*].numApps = 1
*.car[*].app[0].typename = "UdpSink"  # Simulating AlertReceiver
*.car[*].app[0].localPort = 5001

# Configure multicast
*.configurator.config = xmldoc("config.xml")

# --- Mixed Applications Configuration ---
[Config RSU-Cloud-Car-Mixed]
extends = RSU-Cloud-Car

# RSU running multiple applications
*.rsu.numApps = 2
# App[0]: Periodic traffic updates
*.rsu.app[0].typename = "UdpBasicApp"
*.rsu.app[0].destAddresses = "server"
*.rsu.app[0].destPort = 5000
*.rsu.app[0].messageLength = 1000B
*.rsu.app[0].sendInterval = 1s
*.rsu.app[0].startTime = 1s

# App[1]: Emergency alerts
*.rsu.app[1].typename = "UdpBasicApp"  # Simulating AlertSender
*.rsu.app[1].destAddresses = "224.0.0.10"
*.rsu.app[1].destPort = 5001
*.rsu.app[1].messageLength = 500B
*.rsu.app[1].sendInterval = exponential(10s)
*.rsu.app[1].startTime = 1s

# Server running multiple applications
*.server.numApps = 2
# App[0]: Receive traffic updates
*.server.app[0].typename = "UdpSink"
*.server.app[0].localPort = 5000

# App[1]: Send VoIP to specific car
*.server.app[1].typename = "UdpBasicApp"  # Simulating VoIPSender
*.server.app[1].destAddresses = "car[0]"
*.server.app[1].destPort = 5002
*.server.app[1].messageLength = 100B
*.server.app[1].sendInterval = 0.02s
*.server.app[1].startTime = 2s

# Cars running multiple applications
*.car[*].numApps = 2
# App[0]: Receive alerts
*.car[*].app[0].typename = "UdpSink"  # Simulating AlertReceiver
*.car[*].app[0].localPort = 5001

# App[1]: Only car[0] receives VoIP
*.car[0].app[1].typename = "UdpSink"  # Simulating VoIPReceiver
*.car[0].app[1].localPort = 5002
# Other cars' App[1] remains idle
*.car[1..].app[1].typename = "UdpSink"
*.car[1..].app[1].localPort = 5002

# Configure multicast
*.configurator.config = xmldoc("config.xml")